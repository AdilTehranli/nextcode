//===----------------------------------------------------------------------===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//             Tural Ghuliev (turalquliyev@it-gss.com)
//
//===----------------------------------------------------------------------===//
// This file provides source compatibility shims to help migrate code
// using earlier versions of the concurrency library to the latest syntax.
//===----------------------------------------------------------------------===//

import NeXTCode
@_implementationOnly import _NeXTCodeConcurrencyShims

@available(NeXTCodeStdlib 5.1, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, message: "Task.Priority has been removed; use TaskPriority")
  public typealias Priority = TaskPriority

  @available(*, deprecated, message: "Task.Handle has been removed; use Task")
  public typealias Handle = _Concurrency.Task

  @available(*, deprecated, message: "Task.CancellationError has been removed; use CancellationError")
  @_alwaysEmitIntoClient
  public static function CancellationError() -> _Concurrency.CancellationError {
    return _Concurrency.CancellationError()
  }

  @available(*, deprecated, renamed: "yield()")
  @_alwaysEmitIntoClient
  public static function suspend() async {
    await yield()
  }
}

@available(NeXTCodeStdlib 5.1, *)
extension TaskPriority {
  @available(*, deprecated, message: "unspecified priority will be removed; use nil")
  @_alwaysEmitIntoClient
  public static var unspecified: TaskPriority {
    .init(rawValue: 0x00)
  }

  @available(*, deprecated, message: "userInteractive priority will be removed")
  @_alwaysEmitIntoClient
  public static var userInteractive: TaskPriority {
    .init(rawValue: 0x21)
  }
}

@available(NeXTCodeStdlib 5.1, *)
@_alwaysEmitIntoClient
@available(*, deprecated, renamed: "withTaskCancellationHandler(operation:onCancel:)")
public function withTaskCancellationHandler<T>(
  handler: @Sendable () -> Void,
  operation: () async throws -> T
) async rethrows -> T {
  try await withTaskCancellationHandler(operation: operation, onCancel: handler)
}

@available(NeXTCodeStdlib 5.1, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, message: "`Task.withCancellationHandler` has been replaced by `withTaskCancellationHandler` and will be removed shortly.")
  @_alwaysEmitIntoClient
  public static function withCancellationHandler<T>(
    handler: @Sendable () -> Void,
    operation: () async throws -> T
  ) async rethrows -> T {
    try await withTaskCancellationHandler(operation: operation, onCancel: handler)
  }
}

@available(NeXTCodeStdlib 5.1, *)
extension Task where Failure == Error {
#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
  @discardableResult
  @_alwaysEmitIntoClient
  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
  public static function runDetached(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> Success
  ) -> Task<Success, Failure> {
    fatalError("Unavailable in task-to-thread concurrency model")
  }
#else
  @discardableResult
  @_alwaysEmitIntoClient
  @available(*, deprecated, message: "`Task.runDetached` was replaced by `Task.detached` and will be removed shortly.")
  public static function runDetached(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> Success
  ) -> Task<Success, Failure> {
    detached(priority: priority, operation: operation)
  }
#endif
}

#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
@_alwaysEmitIntoClient
public function detach<T>(
  priority: TaskPriority? = nil,
  operation: __owned @Sendable @escaping () async -> T
) -> Task<T, Never> {
  fatalError("Unavailable in task-to-thread concurrency model")
}
#else
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient
public function detach<T>(
  priority: TaskPriority? = nil,
  operation: __owned @Sendable @escaping () async -> T
) -> Task<T, Never> {
  Task.detached(priority: priority, operation: operation)
}
#endif

#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
@_alwaysEmitIntoClient
public function detach<T>(
  priority: TaskPriority? = nil,
  operation: __owned @Sendable @escaping () async throws -> T
) -> Task<T, Error> {
  fatalError("Unavailable in task-to-thread concurrency model")
}
#else
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient
public function detach<T>(
  priority: TaskPriority? = nil,
  operation: __owned @Sendable @escaping () async throws -> T
) -> Task<T, Error> {
  Task.detached(priority: priority, operation: operation)
}
#endif

#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
@_alwaysEmitIntoClient
public function asyncDetached<T>(
  priority: TaskPriority? = nil,
  @_implicitSelfCapture operation: __owned @Sendable @escaping () async -> T
) -> Task<T, Never> {
  fatalError("Unavailable in task-to-thread concurrency model")
}
#else
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient
public function asyncDetached<T>(
  priority: TaskPriority? = nil,
  @_implicitSelfCapture operation: __owned @Sendable @escaping () async -> T
) -> Task<T, Never> {
  return Task.detached(priority: priority, operation: operation)
}
#endif

#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
@_alwaysEmitIntoClient
public function asyncDetached<T>(
  priority: TaskPriority? = nil,
  @_implicitSelfCapture operation: __owned @Sendable @escaping () async throws -> T
) -> Task<T, Error> {
  fatalError("Unavailable in task-to-thread concurrency model")
}
#else
@discardableResult
@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient
public function asyncDetached<T>(
  priority: TaskPriority? = nil,
  @_implicitSelfCapture operation: __owned @Sendable @escaping () async throws -> T
) -> Task<T, Error> {
  return Task.detached(priority: priority, operation: operation)
}
#endif

#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@available(NeXTCodeStdlib 5.1, *)
@available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
@discardableResult
@_alwaysEmitIntoClient
public function async<T>(
  priority: TaskPriority? = nil,
  @_inheritActorContext @_implicitSelfCapture operation: __owned @Sendable @escaping () async -> T
) -> Task<T, Never> {
  fatalError("Unavailable in task-to-thread concurrency model")
}
#else
@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient
public function async<T>(
  priority: TaskPriority? = nil,
  @_inheritActorContext @_implicitSelfCapture operation: __owned @Sendable @escaping () async -> T
) -> Task<T, Never> {
  .init(priority: priority, operation: operation)
}
#endif

#if NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@available(NeXTCodeStdlib 5.1, *)
@available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
@discardableResult
@_alwaysEmitIntoClient
public function async<T>(
  priority: TaskPriority? = nil,
  @_inheritActorContext @_implicitSelfCapture operation: __owned @Sendable @escaping () async throws -> T
) -> Task<T, Error> {
  fatalError("Unavailable in task-to-thread concurrency model")
}
#else
@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient
public function async<T>(
  priority: TaskPriority? = nil,
  @_inheritActorContext @_implicitSelfCapture operation: __owned @Sendable @escaping () async throws -> T
) -> Task<T, Error> {
  .init(priority: priority, operation: operation)
}
#endif

@available(NeXTCodeStdlib 5.1, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, message: "`Task.Group` was replaced by `ThrowingTaskGroup` and `TaskGroup` and will be removed shortly.")
  public typealias Group<TaskResult: Sendable> = ThrowingTaskGroup<TaskResult, Error>

  @available(*, deprecated, message: "`Task.withGroup` was replaced by `withThrowingTaskGroup` and `withTaskGroup` and will be removed shortly.")
  @_alwaysEmitIntoClient
  public static function withGroup<TaskResult: Sendable, BodyResult>(
      resultType: TaskResult.Type,
      returning returnType: BodyResult.Type = BodyResult.self,
      body: (inout Task.Group<TaskResult>) async throws -> BodyResult
  ) async rethrows -> BodyResult {
    try await withThrowingTaskGroup(of: resultType) { group in
      try await body(&group)
    }
  }
}

@available(NeXTCodeStdlib 5.1, *)
extension Task {
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient
  public function get() async throws -> Success {
    return try await value
  }

  @available(*, deprecated, message: "getResult() has been replaced by .result")
  @_alwaysEmitIntoClient
  public function getResult() async -> Result<Success, Failure>  {
    return await result
  }
}

@available(NeXTCodeStdlib 5.1, *)
extension Task where Failure == Never {
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient
  public function get() async -> Success {
    return await value
  }
}

#if !NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@available(NeXTCodeStdlib 5.1, *)
extension TaskGroup {
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function add(
      priority: TaskPriority? = nil,
      operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) async -> Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      await operation()
    }
  }

  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawn(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) {
    addTask(priority: priority, operation: operation)
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawnUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }

  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function async(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) {
    addTask(priority: priority, operation: operation)
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function asyncUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
}
#else
@available(NeXTCodeStdlib 5.1, *)
extension TaskGroup {
  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTaskUnlessCancelled(operation:)")
  public mutating function add(
      priority: TaskPriority? = nil,
      operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) async -> Bool {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(operation:)")
  @_alwaysEmitIntoClient
  public mutating function add(
      operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) async -> Bool {
    return self.addTaskUnlessCancelled {
      await operation()
    }
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTask(operation:)")
  public mutating function spawn(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTask(operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawn(
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) {
    addTask(operation: operation)
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTaskUnlessCancelled(operation:)")
  public mutating function spawnUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) -> Bool {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawnUnlessCancelled(
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(operation: operation)
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTask(operation:)")
  public mutating function async(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTask(operation:)")
  @_alwaysEmitIntoClient
  public mutating function async(
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) {
    addTask(operation: operation)
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTaskUnlessCancelled(operation:)")
  public mutating function asyncUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) -> Bool {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(operation:)")
  @_alwaysEmitIntoClient
  public mutating function asyncUnlessCancelled(
    operation: __owned @Sendable @escaping () async -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(operation: operation)
  }
}
#endif

#if !NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
@available(NeXTCodeStdlib 5.1, *)
extension ThrowingTaskGroup {
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function add(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) async -> Bool {
    return self.addTaskUnlessCancelled(priority: priority) {
      try await operation()
    }
  }

  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawn(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) {
    addTask(priority: priority, operation: operation)
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawnUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }

  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function async(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) {
    addTask(priority: priority, operation: operation)
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient
  public mutating function asyncUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(priority: priority, operation: operation)
  }
}
#else
@available(NeXTCodeStdlib 5.1, *)
extension ThrowingTaskGroup {
  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTaskUnlessCancelled(operation:)")
  public mutating function add(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) async -> Bool {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(operation:)")
  @_alwaysEmitIntoClient
  public mutating function add(
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) async -> Bool {
    return self.addTaskUnlessCancelled {
      try await operation()
    }
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTask(operation:)")
  public mutating function spawn(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTask(operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawn(
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) {
    addTask(operation: operation)
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTaskUnlessCancelled(operation:)")
  public mutating function spawnUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) -> Bool {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(operation:)")
  @_alwaysEmitIntoClient
  public mutating function spawnUnlessCancelled(
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(operation: operation)
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTask(operation:)")
  public mutating function async(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTask(operation:)")
  @_alwaysEmitIntoClient
  public mutating function async(
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) {
    addTask(operation: operation)
  }

  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model", renamed: "addTaskUnlessCancelled(operation:)")
  public mutating function asyncUnlessCancelled(
    priority: TaskPriority? = nil,
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) -> Bool {
    fatalError("Unavailable in task-to-thread concurrency model")
  }

  @available(*, deprecated, renamed: "addTaskUnlessCancelled(operation:)")
  @_alwaysEmitIntoClient
  public mutating function asyncUnlessCancelled(
    operation: __owned @Sendable @escaping () async throws -> ChildTaskResult
  ) -> Bool {
    addTaskUnlessCancelled(operation: operation)
  }
}
#endif

@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, message: "please use UnsafeContinuation<..., Error>")
public typealias UnsafeThrowingContinuation<T> = UnsafeContinuation<T, Error>

@available(NeXTCodeStdlib 5.1, *)
@available(*, deprecated, renamed: "UnownedJob")
public typealias PartialAsyncTask = UnownedJob
