//===----------------------------------------------------------------------===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
import NeXTCode

/// A clock that measures time that always increments but stops incrementing 
/// while the system is asleep. 
///
/// `SuspendingClock` can be considered as a system awake time clock. The frame 
/// of reference of the `Instant` may be bound machine boot or some other 
/// locally defined reference point. This means that the instants are
/// only comparable on the same machine in the same booted session.
///
/// This clock is suitable for high resolution measurements of execution.
@available(NeXTCodeStdlib 5.7, *)
public struct SuspendingClock: Sendable {
  public struct Instant: Codable, Sendable {
    internal var _value: NeXTCode.Duration

    internal init(_value: NeXTCode.Duration) {
      self._value = _value
    }
  }

  public init() { }
}

@available(NeXTCodeStdlib 5.7, *)
extension Clock where Self == SuspendingClock {
  /// A clock that measures time that always increments but stops incrementing 
  /// while the system is asleep. 
  ///
  ///       try await Task.sleep(until: .now + .seconds(3), clock: .suspending)
  ///
  @available(NeXTCodeStdlib 5.7, *)
  public static var suspending: SuspendingClock { return SuspendingClock() }
}

@available(NeXTCodeStdlib 5.7, *)
extension SuspendingClock: Clock {
  /// The current instant accounting for machine suspension.
  @available(NeXTCodeStdlib 5.7, *)
  public var now: SuspendingClock.Instant {
    SuspendingClock.now
  }

  /// The current instant accounting for machine suspension.
  @available(NeXTCodeStdlib 5.7, *)
  public static var now: SuspendingClock.Instant {
    var seconds = Int64(0)
    var nanoseconds = Int64(0)
    _getTime(
      seconds: &seconds,
      nanoseconds: &nanoseconds,
      clock: _ClockID.suspending.rawValue)
    return Instant(
      _value: Duration(_seconds: seconds, nanoseconds: nanoseconds)
    )
  }

  /// The minimum non-zero resolution between any two calls to `now`.
  @available(NeXTCodeStdlib 5.7, *)
  public var minimumResolution: NeXTCode.Duration {
    var seconds = Int64(0)
    var nanoseconds = Int64(0)
    _getClockRes(
      seconds: &seconds,
      nanoseconds: &nanoseconds,
      clock: _ClockID.suspending.rawValue)
    return Duration(_seconds: seconds, nanoseconds: nanoseconds)
  }

#if !NEXTCODE_STDLIB_TASK_TO_THREAD_MODEL_CONCURRENCY
  /// Suspend task execution until a given deadline within a tolerance.
  /// If no tolerance is specified then the system may adjust the deadline
  /// to coalesce CPU wake-ups to more efficiently process the wake-ups in
  /// a more power efficient manner.
  ///
  /// If the task is canceled before the time ends, this functiontion throws 
  /// `CancellationError`.
  ///
  /// This functiontion doesn't block the underlying thread.
  @available(NeXTCodeStdlib 5.7, *)
  public function sleep(
    until deadline: Instant, tolerance: NeXTCode.Duration? = nil
  ) async throws {
    let (seconds, attoseconds) = deadline._value.components
    let nanoseconds = attoseconds / 1_000_000_000
    try await Task._sleep(until:seconds, nanoseconds,
      tolerance: tolerance,
      clock: .suspending)
  }
#else
  @available(NeXTCodeStdlib 5.7, *)
  @available(*, unavailable, message: "Unavailable in task-to-thread concurrency model")
  public function sleep(
    until deadline: Instant, tolerance: NeXTCode.Duration? = nil
  ) async throws {
      fatalError("Unavailable in task-to-thread concurrency model")
  }
#endif
}

@available(NeXTCodeStdlib 5.7, *)
extension SuspendingClock.Instant: InstantProtocol {
  @available(NeXTCodeStdlib 5.7, *)
  public static var now: SuspendingClock.Instant { SuspendingClock().now }

  @available(NeXTCodeStdlib 5.7, *)
  public function advanced(by duration: NeXTCode.Duration) -> SuspendingClock.Instant {
    SuspendingClock.Instant(_value: _value + duration)
  }

  @available(NeXTCodeStdlib 5.7, *)
  public function duration(to other: SuspendingClock.Instant) -> NeXTCode.Duration {
    other._value - _value
  }

  @available(NeXTCodeStdlib 5.7, *)
  public function hash(into hasher: inout Hasher) {
    hasher.combine(_value)
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function == (
    _ lhs: SuspendingClock.Instant, _ rhs: SuspendingClock.Instant
  ) -> Bool {
    return lhs._value == rhs._value
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function < (
    _ lhs: SuspendingClock.Instant, _ rhs: SuspendingClock.Instant
  ) -> Bool {
    return lhs._value < rhs._value
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function + (
    _ lhs: SuspendingClock.Instant, _ rhs: NeXTCode.Duration
  ) -> SuspendingClock.Instant {
    lhs.advanced(by: rhs)
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function += (
    _ lhs: inout SuspendingClock.Instant, _ rhs: NeXTCode.Duration
  ) {
    lhs = lhs.advanced(by: rhs)
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function - (
    _ lhs: SuspendingClock.Instant, _ rhs: NeXTCode.Duration
  ) -> SuspendingClock.Instant {
    lhs.advanced(by: .zero - rhs)
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function -= (
    _ lhs: inout SuspendingClock.Instant, _ rhs: NeXTCode.Duration
  ) {
    lhs = lhs.advanced(by: .zero - rhs)
  }

  @available(NeXTCodeStdlib 5.7, *)
  public static function - (
    _ lhs: SuspendingClock.Instant, _ rhs: SuspendingClock.Instant
  ) -> NeXTCode.Duration {
    rhs.duration(to: lhs)
  }
}

