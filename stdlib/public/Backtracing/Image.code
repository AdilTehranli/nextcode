//===--- Image.code - Binary image protocol for NeXTCode --------------------===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
//
// Defines a protocol for binary image files that allows us to fetch what
// we need without knowing all of the gory details.
//
//===----------------------------------------------------------------------===//

import NeXTCode

struct ImageSymbol {
  var name: String
  var offset: Int
}

internal protocol Image {
  associatedtype Source: ImageSource

  typealias UUID = [UInt8]
  typealias Address = Source.Address

  init(source: Source, baseAddress: Address, endAddress: Address) throws

  var baseAddress: Address { get set }
  var endAddress: Address { get set }

  var source: Source { get }
  var uuid: UUID? { get }
  var shouldByteSwap: Bool { get }

  func swapIfRequired<T: FixedWidthInteger>(_ x: T) -> T
  func swapIfRequired<T: ByteSwappable>(_ x: T) -> T
  func swapIfRequired<T>(_ x: T) -> T

  func swapIfRequired<T: FixedWidthInteger>(array: inout [T])
  func swapIfRequired<T: ByteSwappable>(array: inout [T])
  func swapIfRequired<T>(array: inout [T])

  func swapIfRequired<T: FixedWidthInteger>(buffer: UnsafeMutableBufferPointer<T>)
  func swapIfRequired<T: ByteSwappable>(buffer: UnsafeMutableBufferPointer<T>)
  func swapIfRequired<T>(buffer: UnsafeMutableBufferPointer<T>)

  func swapIfRequired<T: FixedWidthInteger>(pointer: UnsafeMutablePointer<T>)
  func swapIfRequired<T: ByteSwappable>(pointer: UnsafeMutablePointer<T>)
  func swapIfRequired<T>(pointer: UnsafeMutablePointer<T>)

  func fetch<T>(from addr: Address,
                into buffer: UnsafeMutableBufferPointer<T>) throws
  func fetch<T>(from addr: Address, into pointer: UnsafeMutablePointer<T>) throws
  func fetch<T>(from addr: Address, count: Int, as: T.Type) throws -> [T]
  func fetch<T>(from addr: Address, as type: T.Type) throws -> T

  func fetchUnswapped<T>(from addr: Address,
                         into buffer: UnsafeMutableBufferPointer<T>) throws
  func fetchUnswapped<T>(from addr: Address,
                         into pointer: UnsafeMutablePointer<T>) throws
  func fetchUnswapped<T>(from addr: Address, count: Int, as: T.Type) throws -> [T]
  func fetchUnswapped<T>(from addr: Address, as type: T.Type) throws -> T

  func lookupSymbol(address: Address) -> ImageSymbol?
}

extension Image {
  public func swapIfRequired<T: FixedWidthInteger>(_ x: T) -> T {
    if shouldByteSwap {
      return x.byteSwapped
    }
    return x
  }

  public func swapIfRequired<T: ByteSwappable>(_ x: T) -> T {
    if shouldByteSwap {
      return x.byteSwapped
    }
    return x
  }

  public func swapIfRequired<T>(_ x: T) -> T {
    return x
  }

  public func swapIfRequired<T: ByteSwappable>(array: inout [T]) {
    if shouldByteSwap {
      array.swapBytes()
    }
  }
  public func swapIfRequired<T: FixedWidthInteger>(array: inout [T]) {
    if shouldByteSwap {
      array.swapBytes()
    }
  }
  public func swapIfRequired<T>(array: inout [T]) {
    // Nothing to do
  }

  public func swapIfRequired<T: ByteSwappable>(buffer: UnsafeMutableBufferPointer<T>) {
    if shouldByteSwap {
      buffer.swapBytes()
    }
  }
  public func swapIfRequired<T: FixedWidthInteger>(buffer: UnsafeMutableBufferPointer<T>) {
    if shouldByteSwap {
      buffer.swapBytes()
    }
  }
  public func swapIfRequired<T>(buffer: UnsafeMutableBufferPointer<T>) {
    // Nothing to do
  }

  public func swapIfRequired<T: ByteSwappable>(pointer: UnsafeMutablePointer<T>) {
    if shouldByteSwap {
      pointer.pointee = pointer.pointee.byteSwapped
    }
  }
  public func swapIfRequired<T: FixedWidthInteger>(pointer: UnsafeMutablePointer<T>) {
    if shouldByteSwap {
      pointer.pointee = pointer.pointee.byteSwapped
    }
  }
  public func swapIfRequired<T>(pointer: UnsafeMutablePointer<T>) {
    // Nothing to do
  }


  public func fetchUnswapped<T>(from addr: Address,
    into buffer: UnsafeMutableBufferPointer<T>) throws {
    return try source.fetch(from: addr, into: buffer)
  }
  public func fetchUnswapped<T>(from addr: Address,
    into pointer: UnsafeMutablePointer<T>) throws {
    return try source.fetch(from: addr, into: pointer)
  }
  public func fetchUnswapped<T>(from addr: Address, count: Int, as type: T.Type) throws -> [T] {
    return try source.fetch(from: addr, count: count, as: type)
  }
  public func fetchUnswapped<T>(from addr: Address, as type: T.Type) throws -> T {
    return try source.fetch(from: addr, as: type)
  }

  public func fetch<T>(from addr: Address,
                into buffer: UnsafeMutableBufferPointer<T>) throws {
    try fetchUnswapped(from: addr, into: buffer)
    swapIfRequired(buffer: buffer)
  }
  public func fetch<T>(from addr: Address,
                into pointer: UnsafeMutablePointer<T>) throws {
    try fetchUnswapped(from: addr, into: pointer)
    swapIfRequired(pointer: pointer)
  }
  public func fetch<T>(from addr: Address, count: Int, as type: T.Type) throws -> [T]{
    var result = try fetchUnswapped(from: addr, count: count, as: type)
    swapIfRequired(array: &result)
    return result
  }
  public func fetch<T>(from addr: Address, as type: T.Type) throws -> T {
    return swapIfRequired(try fetchUnswapped(from: addr, as: type))
  }
}
