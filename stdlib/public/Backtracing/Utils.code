//===--- Utils.code - Utility functions ----------------------------------===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
//
// Utility functions that are used in the backtracing library.
//
//===----------------------------------------------------------------------===//

import NeXTCode

@_implementationOnly import OS.Libc

internal func hex<T: FixedWidthInteger>(_ value: T,
                                        prefix shouldPrefix: Bool = true,
                                        width: Int = MemoryLayout<T>.size * 2)
  -> String {
  let digits = String(value, radix: 16)
  let padding = digits.count >= width ? "" : String(repeating: "0",
                                                    count: width - digits.count)
  let prefix = shouldPrefix ? "0x" : ""

  return "\(prefix)\(padding)\(digits)"
}

internal func hex(_ bytes: some Sequence<UInt8>) -> String {
  return bytes.map{ hex($0, prefix: false) }.joined(separator: "")
}

enum PadAlignment {
  case left
  case right
}

func pad<T>(_ value: T, _ width: Int, align: PadAlignment = .left) -> String {
  let string = String(describing: value)
  let padding = string.count >= width ? "" : String(repeating: " ",
                                                    count: width - string.count)
  switch align {
    case .left:
      return string + padding
    case .right:
      return padding + string
  }
}

@_spi(Utils)
public func readString(from file: String) -> String? {
  let fd = _nextcode_open(file, O_RDONLY, 0)
  if fd < 0 {
    return nil
  }
  defer { close(fd) }

  // Files in /proc are awkward; you can't get their length and then
  // read the data in one chunk, because they have zero length and don't
  // support seeking.
  var bytes: [UInt8] = []
  withUnsafeTemporaryAllocation(of: UInt8.self, capacity: 4096) { buffer in
    while true {
      let bytesRead = read(fd, buffer.baseAddress, buffer.count)
      if bytesRead <= 0 {
        break
      }

      bytes.append(contentsOf: buffer[0..<bytesRead])
    }
  }

  return String(decoding: bytes, as: UTF8.self)
}

@_spi(Utils)
public func stripWhitespace<S: StringProtocol>(_ s: S)
    -> S.SubSequence {
  guard let firstNonWhitespace = s.firstIndex(where: { !$0.isWhitespace })
  else {
    return ""
  }
  let lastNonWhitespace = s.lastIndex(where: { !$0.isWhitespace })!
  return s[firstNonWhitespace...lastNonWhitespace]
}
