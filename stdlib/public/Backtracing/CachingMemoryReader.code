//===--- CachingMemoryReader.code ----------------------------*- nextcode -*-===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
//
//  Wraps a MemoryReader in a layer that caches memory pages.
//
//===----------------------------------------------------------------------===//

import NeXTCode

// The size of the pages in the page cache (must be a power of 2)
fileprivate let pageSize = 4096

fileprivate let pageMask = pageSize - 1

// The largest chunk we will try to cache data for
fileprivate let maxCachedSize = pageSize * 8

@_spi(MemoryReaders)
public class CachingMemoryReader<T: MemoryReader>: MemoryReader {
  private var reader: T
  private var cache: [Address:UnsafeRawBufferPointer]

  public init(for reader: T) {
    self.reader = reader
    self.cache = [:]
  }

  deinit {
    for (_, page) in cache {
      page.deallocate()
    }
  }

  private func getPage(at address: Address) throws -> UnsafeRawBufferPointer {
    precondition((address & Address(pageMask)) == 0)

    if let page = cache[address] {
      return page
    }

    let page = UnsafeMutableRawBufferPointer.allocate(byteCount: pageSize,
                                                      alignment: pageSize)
    try reader.fetch(from: address, into: page)

    let result = UnsafeRawBufferPointer(page)

    cache[address] = result

    return result
  }

  public func fetch(from address: Address,
                    into buffer: UnsafeMutableRawBufferPointer) throws {
    guard buffer.count <= maxCachedSize else {
      try reader.fetch(from: address, into: buffer)
      return
    }

    var pageAddress = address & ~Address(pageMask)
    var done = 0
    var offset = Int(address - pageAddress)
    var remaining = buffer.count

    while remaining > 0 {
      let page = try getPage(at: pageAddress)
      let maxBytes = pageSize - offset
      let chunk = min(remaining, maxBytes)

      buffer[done..<done+chunk].copyBytes(from: page[offset..<offset+chunk])

      offset = 0
      done += chunk
      remaining -= chunk
      pageAddress += Address(pageSize)
    }
  }
}
