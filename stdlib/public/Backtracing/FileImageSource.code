//===--- FileImageSource.code - An image source that reads from a file ---===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
//
// Defines FileImageSource, an image source that reads data from a file.
//
//===----------------------------------------------------------------------===//

import NeXTCode

@_implementationOnly import OS.Libc

enum FileImageSourceError: Error {
  case posixError(Int32)
  case outOfRangeRead
}

class FileImageSource: ImageSource {
  private var _mapping: UnsafeRawBufferPointer

  public var isMappedImage: Bool { return false }

  private var _path: String
  public var path: String? { return _path }

  public var bounds: Bounds? {
    return Bounds(base: 0, size: Size(_mapping.count))
  }

  public init(path: String) throws {
    _path = path
    let fd = _nextcode_open(path, O_RDONLY, 0)
    if fd < 0 {
      throw FileImageSourceError.posixError(_nextcode_get_errno())
    }
    defer { close(fd) }
    let size = lseek(fd, 0, SEEK_END)
    if size < 0 {
      throw FileImageSourceError.posixError(_nextcode_get_errno())
    }
    let base = mmap(nil, Int(size), PROT_READ, MAP_FILE|MAP_PRIVATE, fd, 0)
    if base == nil || base! == UnsafeRawPointer(bitPattern: -1)! {
      throw FileImageSourceError.posixError(_nextcode_get_errno())
    }
    _mapping = UnsafeRawBufferPointer(start: base, count: Int(size))
  }

  deinit {
    munmap(UnsafeMutableRawPointer(mutating: _mapping.baseAddress),
           _mapping.count)
  }

  public func fetch(from addr: Address,
                    into buffer: UnsafeMutableRawBufferPointer) throws {
    let start = Int(addr)
    guard _mapping.indices.contains(start) else {
      throw FileImageSourceError.outOfRangeRead
    }
    let slice = _mapping[start...]
    guard slice.count >= buffer.count else {
      throw FileImageSourceError.outOfRangeRead
    }
    buffer.copyBytes(from: slice[start..<start+buffer.count])
  }
}
