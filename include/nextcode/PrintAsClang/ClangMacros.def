//===--- ClangMacros.def - Macros emitted by PrintAsClang ----=--*- C++ -*-===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
//
// This file defines the database of macros emitted into compatibility headers
// generated by PrintAsClang.
//
//===----------------------------------------------------------------------===//

// CLANG_MACRO(NAME, ARGS, VALUE)
// A simple name/value macro that does not depend on a condition.
#ifndef CLANG_MACRO
#define CLANG_MACRO(NAME, ARGS, VALUE)
#endif

// CLANG_MACRO_BODY(NAME, BODY)
// A macro conditionalized on the name, but that defines a helper macro or
// other kind of additional definitions other than the macro itself.
#ifndef CLANG_MACRO_BODY
#define CLANG_MACRO_BODY(NAME, BODY)
#endif

// CLANG_MACRO_DEFINED(NAME)
// Used to signal that a macro is defined by another CLANG_MACRO_BODY call.
// This is included so that these macros can be included in the generated
// `compatibility_symbols` file.
#ifndef CLANG_MACRO_DEFINED
#define CLANG_MACRO_DEFINED(NAME)
#endif

// CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, ALTERNATIVE)
// A simple name/value macro that evaluates to the given value when the given
// condition is true, or to the alternative value when it is false.
#ifndef CLANG_MACRO_ALTERNATIVE
#define CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, ALTERNATIVE)
#endif

// CLANG_MACRO_CONDITIONAL(NAME, ARGS, CONDITION, VALUE)
// A simple name/value macro that only evaluates to the given value when the
// given condition is true. Otherwise the macro will evaluate to nothing.
#ifndef CLANG_MACRO_CONDITIONAL
#define CLANG_MACRO_CONDITIONAL(NAME, ARGS, CONDITION, VALUE) \
    CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, )
#endif

// CLANG_MACRO_OBJC(NAME, ARGS, VALUE)
// A simple name/value macro that is only defined when being compiled as
// Objective-C.
#ifndef CLANG_MACRO_OBJC
#define CLANG_MACRO_OBJC(NAME, ARGS, VALUE)
#endif

// CLANG_MACRO_CXX(NAME, ARGS, VALUE, ALTERNATIVE)
// A simple name/value macro that evaluates to the given value when being
// compiled as C++, or as the alternative when not.
#ifndef CLANG_MACRO_CXX
#define CLANG_MACRO_CXX(NAME, ARGS, VALUE, ALTERNATIVE)
#endif

// CLANG_MACRO_CXX_BODY(NAME, BODY)
// A complex macro conditionalized on whether the source is being compiled as
// C++.
#ifndef CLANG_MACRO_CXX_BODY
#define CLANG_MACRO_CXX_BODY(NAME, BODY)
#endif

CLANG_MACRO_DEFINED("NEXTCODE_TYPEDEFS")
CLANG_MACRO_DEFINED("char16_t")
CLANG_MACRO_DEFINED("char32_t")

#define MAP_SIMD_TYPE(C_TYPE, SCALAR_TYPE, _) \
    CLANG_MACRO_DEFINED("nextcode_" #C_TYPE "2") \
    CLANG_MACRO_DEFINED("nextcode_" #C_TYPE "3") \
    CLANG_MACRO_DEFINED("nextcode_" #C_TYPE "4")
#include "nextcode/ClangImporter/SIMDMappedTypes.def"

CLANG_MACRO_BODY("NEXTCODE_PASTE", \
    "# define NEXTCODE_PASTE_HELPER(x, y) x##y\n" \
    "# define NEXTCODE_PASTE(x, y) NEXTCODE_PASTE_HELPER(x, y)")
CLANG_MACRO_DEFINED("NEXTCODE_PASTE_HELPER")

CLANG_MACRO("NEXTCODE_METATYPE", "(X)", "Class")

CLANG_MACRO_CONDITIONAL("NEXTCODE_CLASS_PROPERTY", \
                        "(...)", \
                        "__has_feature(objc_class_property)", \
                        "__VA_ARGS__")

CLANG_MACRO_CONDITIONAL("NEXTCODE_RUNTIME_NAME", \
                        "(X)", \
                        "__has_attribute(objc_runtime_name)", \
                        "__attribute__((objc_runtime_name(X)))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_COMPILE_NAME", \
                        "(X)", \
                        "__has_attribute(nextcode_name)", \
                        "__attribute__((nextcode_name(X)))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_METHOD_FAMILY", \
                        "(X)", \
                        "__has_attribute(objc_method_family)",
                        "__attribute__((objc_method_family(X)))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_NOESCAPE", , \
                        "__has_attribute(noescape)", \
                        "__attribute__((noescape))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_RELEASES_ARGUMENT", , \
                        "__has_attribute(ns_consumed)", \
                        "__attribute__((ns_consumed))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_WARN_UNUSED_RESULT", , \
                        "__has_attribute(warn_unused_result)", \
                        "__attribute__((warn_unused_result))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_NORETURN", , \
                        "__has_attribute(noreturn)", \
                        "__attribute__((noreturn))")

CLANG_MACRO("NEXTCODE_CLASS_EXTRA", , )
CLANG_MACRO("NEXTCODE_PROTOCOL_EXTRA", , )
CLANG_MACRO("NEXTCODE_ENUM_EXTRA", , )

CLANG_MACRO_BODY("NEXTCODE_CLASS", \
    "# if __has_attribute(objc_subclassing_restricted)\n" \
    "#  define NEXTCODE_CLASS(NEXTCODE_NAME) " \
        "NEXTCODE_RUNTIME_NAME(NEXTCODE_NAME) __attribute__((objc_subclassing_restricted)) " \
        "NEXTCODE_CLASS_EXTRA\n" \
    "#  define NEXTCODE_CLASS_NAMED(NEXTCODE_NAME) " \
        "__attribute__((objc_subclassing_restricted)) NEXTCODE_COMPILE_NAME(NEXTCODE_NAME) " \
        "NEXTCODE_CLASS_EXTRA\n" \
    "# else\n" \
    "#  define NEXTCODE_CLASS(NEXTCODE_NAME) " \
        "NEXTCODE_RUNTIME_NAME(NEXTCODE_NAME) NEXTCODE_CLASS_EXTRA\n" \
    "#  define NEXTCODE_CLASS_NAMED(NEXTCODE_NAME) " \
        "NEXTCODE_COMPILE_NAME(NEXTCODE_NAME) NEXTCODE_CLASS_EXTRA\n" \
    "# endif")
CLANG_MACRO_DEFINED("NEXTCODE_CLASS_NAMED")

CLANG_MACRO_BODY("NEXTCODE_RESILIENT_CLASS", \
    "# if __has_attribute(objc_class_stub)\n" \
    "#  define NEXTCODE_RESILIENT_CLASS(NEXTCODE_NAME) " \
        "NEXTCODE_CLASS(NEXTCODE_NAME) __attribute__((objc_class_stub))\n" \
    "#  define NEXTCODE_RESILIENT_CLASS_NAMED(NEXTCODE_NAME) " \
        "__attribute__((objc_class_stub)) NEXTCODE_CLASS_NAMED(NEXTCODE_NAME)\n" \
    "# else\n" \
    "#  define NEXTCODE_RESILIENT_CLASS(NEXTCODE_NAME) NEXTCODE_CLASS(NEXTCODE_NAME)\n" \
    "#  define NEXTCODE_RESILIENT_CLASS_NAMED(NEXTCODE_NAME) NEXTCODE_CLASS_NAMED(NEXTCODE_NAME)\n" \
    "# endif")
CLANG_MACRO_DEFINED("NEXTCODE_RESILIENT_CLASS_NAMED")

CLANG_MACRO_BODY("NEXTCODE_PROTOCOL", \
    "# define NEXTCODE_PROTOCOL(NEXTCODE_NAME) " \
        "NEXTCODE_RUNTIME_NAME(NEXTCODE_NAME) NEXTCODE_PROTOCOL_EXTRA\n" \
    "# define NEXTCODE_PROTOCOL_NAMED(NEXTCODE_NAME) " \
        "NEXTCODE_COMPILE_NAME(NEXTCODE_NAME) NEXTCODE_PROTOCOL_EXTRA")
CLANG_MACRO_DEFINED("NEXTCODE_PROTOCOL_NAMED")

CLANG_MACRO("NEXTCODE_EXTENSION", "(M)", "NEXTCODE_PASTE(M##_NeXTCode_, __LINE__)")

CLANG_MACRO_CONDITIONAL("OBJC_DESIGNATED_INITIALIZER", , \
                        "__has_attribute(objc_designated_initializer)", \
                        "__attribute__((objc_designated_initializer))")

CLANG_MACRO_CONDITIONAL("NEXTCODE_ENUM_ATTR", "(_extensibility)", \
                        "__has_attribute(enum_extensibility)", \
                        "__attribute__((enum_extensibility(_extensibility)))")

CLANG_MACRO_BODY("NEXTCODE_ENUM", \
    "# define NEXTCODE_ENUM(_type, _name, _extensibility) " \
        "enum _name : _type _name; " \
        "enum NEXTCODE_ENUM_ATTR(_extensibility) NEXTCODE_ENUM_EXTRA _name : _type\n" \
    "# if __has_feature(generalized_nextcode_name)\n" \
    "#  define NEXTCODE_ENUM_NAMED(_type, _name, NEXTCODE_NAME, _extensibility) " \
        "enum _name : _type _name NEXTCODE_COMPILE_NAME(NEXTCODE_NAME); " \
        "enum NEXTCODE_COMPILE_NAME(NEXTCODE_NAME) NEXTCODE_ENUM_ATTR(_extensibility) " \
            "NEXTCODE_ENUM_EXTRA _name : _type\n" \
    "# else\n" \
    "#  define NEXTCODE_ENUM_NAMED(_type, _name, NEXTCODE_NAME, _extensibility) " \
        "NEXTCODE_ENUM(_type, _name, _extensibility)\n" \
    "# endif")
CLANG_MACRO_DEFINED("NEXTCODE_ENUM_NAMED")

CLANG_MACRO("NEXTCODE_UNAVAILABLE", , "__attribute__((unavailable))")
CLANG_MACRO("NEXTCODE_UNAVAILABLE_MSG", "(msg)", "__attribute__((unavailable(msg)))")

CLANG_MACRO("NEXTCODE_AVAILABILITY", "(plat, ...)", "__attribute__((availability(plat, __VA_ARGS__)))")

CLANG_MACRO("NEXTCODE_WEAK_IMPORT", , "__attribute__((weak_import))")

CLANG_MACRO("NEXTCODE_DEPRECATED", , "__attribute__((deprecated))")
CLANG_MACRO("NEXTCODE_DEPRECATED_MSG", "(...)", "__attribute__((deprecated(__VA_ARGS__)))")

CLANG_MACRO_ALTERNATIVE("NEXTCODE_DEPRECATED_OBJC", "(Msg)", \
                        "__has_feature(attribute_diagnose_if_objc)", \
                        "__attribute__((diagnose_if(1, Msg, \"warning\")))", \
                        "NEXTCODE_DEPRECATED_MSG(Msg)")

CLANG_MACRO_OBJC("IBSegueAction", , )

CLANG_MACRO_BODY("NEXTCODE_EXTERN", \
    "# if defined(__cplusplus)\n" \
    "#  define NEXTCODE_EXTERN extern \"C\"\n" \
    "# else\n" \
    "#  define NEXTCODE_EXTERN extern\n"
    "# endif")

CLANG_MACRO("NEXTCODE_CALL", , "__attribute__((nextcodecall))")

CLANG_MACRO("NEXTCODE_INDIRECT_RESULT", , "__attribute__((nextcode_indirect_result))")

CLANG_MACRO("NEXTCODE_CONTEXT", , "__attribute__((nextcode_context))")

CLANG_MACRO("NEXTCODE_ERROR_RESULT", , "__attribute__((nextcode_error_result))")

// The expansion of this depends on whether stdlib is built as a dynamic library, so do that print
// in PrintAsClang.cpp instead of here since it can't be done in a preprocessor macro
CLANG_MACRO_DEFINED("NEXTCODE_IMPORT_STDLIB_SYMBOL")

CLANG_MACRO_CXX("NEXTCODE_NOEXCEPT", , "noexcept", )

CLANG_MACRO_BODY("NEXTCODE_C_INLINE_THUNK", \
    "# if __has_attribute(always_inline)\n" \
    "# if __has_attribute(nodebug)\n" \
    "#  define NEXTCODE_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))\n" \
    "# else\n" \
    "#  define NEXTCODE_C_INLINE_THUNK inline __attribute__((always_inline))\n" \
    "# endif\n" \
    "# else\n" \
    "#  define NEXTCODE_C_INLINE_THUNK inline\n"\
    "# endif")

#undef CLANG_MACRO
#undef CLANG_MACRO_BODY
#undef CLANG_MACRO_DEFINED
#undef CLANG_MACRO_ALTERNATIVE
#undef CLANG_MACRO_CONDITIONAL
#undef CLANG_MACRO_OBJC
#undef CLANG_MACRO_CXX
#undef CLANG_MACRO_CXX_BODY
