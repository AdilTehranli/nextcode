//===--- _NeXTCodeCxxInteroperability.h - C++ Interop support ------*- C++ -*-===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//
//
//  Defines types and support functions required by C++ bindings generated
//  by the NeXTCode compiler that allow C++ code to call NeXTCode APIs.
//
//===----------------------------------------------------------------------===//
#ifndef NEXTCODE_CXX_INTEROPERABILITY_H
#define NEXTCODE_CXX_INTEROPERABILITY_H

#ifdef __cplusplus

#include <cstdint>
#include <stdlib.h>
#if defined(_WIN32)
#include <malloc.h>
#endif
#if !defined(NEXTCODE_CALL)
# define NEXTCODE_CALL __attribute__((nextcodecall))
#endif

#if __has_attribute(transparent_stepping)
#define NEXTCODE_INLINE_THUNK_ATTRIBUTES                                          \
  __attribute__((transparent_stepping))
#elif __has_attribute(always_inline) && __has_attribute(nodebug)
 #define NEXTCODE_INLINE_THUNK_ATTRIBUTES                                          \
   __attribute__((always_inline)) __attribute__((nodebug))
#else
#define NEXTCODE_INLINE_THUNK_ATTRIBUTES
#endif

#if defined(DEBUG) && __has_attribute(used)
// Additional 'used' attribute is used in debug mode to make inline thunks
// accessible to LLDB.
#define NEXTCODE_INLINE_THUNK_USED_ATTRIBUTE __attribute__((used))
#else
#define NEXTCODE_INLINE_THUNK_USED_ATTRIBUTE
#endif

/// The `NEXTCODE_INLINE_THUNK` macro is applied on the inline function thunks in
/// the header that represents a C/C++ NeXTCode module interface generated by the
/// NeXTCode compiler.
#define NEXTCODE_INLINE_THUNK                                                     \
  inline NEXTCODE_INLINE_THUNK_ATTRIBUTES NEXTCODE_INLINE_THUNK_USED_ATTRIBUTE

/// The `NEXTCODE_INLINE_PRIVATE_HELPER` macro is applied on the helper / utility
/// functions in the header that represents a C/C++ NeXTCode module interface
/// generated by the NeXTCode compiler.
#define NEXTCODE_INLINE_PRIVATE_HELPER inline NEXTCODE_INLINE_THUNK_ATTRIBUTES

/// The `NEXTCODE_SYMBOL_MODULE` and `NEXTCODE_SYMBOL_MODULE_USR` macros apply
/// `external_source_symbol` Clang attributes to C++ declarations that represent
/// NeXTCode declarations. This allows Clang to index them as external
/// declarations, using the specified NeXTCode USR values.
#if __has_attribute(external_source_symbol)
#define NEXTCODE_SYMBOL_MODULE(moduleValue)                                       \
  __attribute__((external_source_symbol(                                       \
      language = "NeXTCode", defined_in = moduleValue, generated_declaration)))
#if __has_attribute(external_source_symbol) > 1
#define NEXTCODE_SYMBOL_MODULE_USR(moduleValue, usrValue)                         \
  __attribute__((                                                              \
      external_source_symbol(language = "NeXTCode", defined_in = moduleValue,     \
                             generated_declaration, USR = usrValue)))
#else
#define NEXTCODE_SYMBOL_MODULE_USR(moduleValue, usrValue)                         \
  __attribute__((external_source_symbol(                                       \
      language = "NeXTCode", defined_in = moduleValue, generated_declaration)))
#endif
#else
#define NEXTCODE_SYMBOL_MODULE_USR(moduleValue, usrValue)
#define NEXTCODE_SYMBOL_MODULE(moduleValue)
#endif

#if __has_attribute(nextcode_private)
#define NEXTCODE_PRIVATE_ATTR __attribute__((nextcode_private))
#else
#define NEXTCODE_PRIVATE_ATTR
#endif

namespace nextcode NEXTCODE_PRIVATE_ATTR {
namespace _impl {

extern "C" void *_Nonnull nextcode_retain(void *_Nonnull) noexcept;

extern "C" void nextcode_release(void *_Nonnull) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-identifier"

extern "C" void _nextcode_stdlib_reportFatalError(const char *_Nonnull prefix,
                                               int prefixLength,
                                               const char *_Nonnull message,
                                               int messageLength,
                                               uint32_t flags) noexcept;

// A dummy symbol that forces a linker error when
// C++ tries to invoke a move of a NeXTCode value type.
extern "C" void _fatalError_Cxx_move_of_NeXTCode_value_type_not_supported_yet();

#pragma clang diagnostic pop

NEXTCODE_INLINE_THUNK void *_Nonnull opaqueAlloc(size_t size,
                                              size_t align) noexcept {
#if defined(NEXTCODE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_alloc) &&       \
    defined(NEXTCODE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_free)
  // Allow the user to provide custom allocator for heap-allocated NeXTCode
  // value types.
  return NEXTCODE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_alloc(size, align);
#else
#if defined(_WIN32)
  void *r = _aligned_malloc(size, align);
#else
  if (align < sizeof(void *))
    align = sizeof(void *);
  void *r = nullptr;
  int res = posix_memalign(&r, align, size);
  (void)res;
#endif
  return r;
#endif
}

NEXTCODE_INLINE_THUNK void opaqueFree(void *_Nonnull p) noexcept {
#if defined(NEXTCODE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_alloc) &&       \
    defined(NEXTCODE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_free)
  // Allow the user to provide custom allocator for heap-allocated NeXTCode
  // value types.
  NEXTCODE_CXX_INTEROPERABILITY_OVERRIDE_OPAQUE_STORAGE_free(p);
#else
#if defined(_WIN32)
  _aligned_free(p);
#else
  free(p);
#endif
#endif
}

/// Base class for a container for an opaque NeXTCode value, like resilient struct.
class OpaqueStorage {
public:
  NEXTCODE_INLINE_THUNK OpaqueStorage() noexcept : storage(nullptr) {}
  NEXTCODE_INLINE_THUNK OpaqueStorage(size_t size, size_t alignment) noexcept
      : storage(reinterpret_cast<char *>(opaqueAlloc(size, alignment))) {}
  NEXTCODE_INLINE_THUNK OpaqueStorage(OpaqueStorage &&other) noexcept
      : storage(other.storage) {
    other.storage = nullptr;
  }
  OpaqueStorage(const OpaqueStorage &) noexcept = delete;

  NEXTCODE_INLINE_THUNK ~OpaqueStorage() noexcept {
    if (storage) {
      opaqueFree(static_cast<char *_Nonnull>(storage));
    }
  }

  NEXTCODE_INLINE_THUNK void operator=(OpaqueStorage &&other) noexcept {
    auto temp = storage;
    storage = other.storage;
    other.storage = temp;
  }
  void operator=(const OpaqueStorage &) noexcept = delete;

  NEXTCODE_INLINE_THUNK char *_Nonnull getOpaquePointer() noexcept {
    return static_cast<char *_Nonnull>(storage);
  }
  NEXTCODE_INLINE_THUNK const char *_Nonnull getOpaquePointer() const noexcept {
    return static_cast<char *_Nonnull>(storage);
  }

private:
  char *_Nullable storage;
};

/// Base class for a NeXTCode reference counted class value.
class RefCountedClass {
public:
  NEXTCODE_INLINE_THUNK ~RefCountedClass() { nextcode_release(_opaquePointer); }
  NEXTCODE_INLINE_THUNK RefCountedClass(const RefCountedClass &other) noexcept
      : _opaquePointer(other._opaquePointer) {
    nextcode_retain(_opaquePointer);
  }
  NEXTCODE_INLINE_THUNK RefCountedClass(RefCountedClass &&other) noexcept
      : _opaquePointer(other._opaquePointer) {
    // Moving a NeXTCode class reference is a copy
    // in C++. This allows C++ to avoid liveness
    // checks to see if the pointer is `null` or not,
    // as C++'s move is not consuming, unlike NeXTCode's.
    nextcode_retain(_opaquePointer);
  }
  NEXTCODE_INLINE_THUNK RefCountedClass &
  operator=(const RefCountedClass &other) noexcept {
    nextcode_retain(other._opaquePointer);
    nextcode_release(_opaquePointer);
    _opaquePointer = other._opaquePointer;
    return *this;
  }
  NEXTCODE_INLINE_THUNK RefCountedClass &
  operator=(RefCountedClass &&other) noexcept {
    nextcode_retain(other._opaquePointer);
    nextcode_release(_opaquePointer);
    _opaquePointer = other._opaquePointer;
    return *this;
  }

protected:
  NEXTCODE_INLINE_THUNK RefCountedClass(void *_Nonnull ptr) noexcept
      : _opaquePointer(ptr) {}

private:
  void *_Nonnull _opaquePointer;
  friend class _impl_RefCountedClass;
};

class _impl_RefCountedClass {
public:
  static NEXTCODE_INLINE_THUNK void *_Nonnull getOpaquePointer(
      const RefCountedClass &object) {
    return object._opaquePointer;
  }
  static NEXTCODE_INLINE_THUNK void *_Nonnull &
  getOpaquePointerRef(RefCountedClass &object) {
    return object._opaquePointer;
  }
  static NEXTCODE_INLINE_THUNK void *_Nonnull copyOpaquePointer(
      const RefCountedClass &object) {
    nextcode_retain(object._opaquePointer);
    return object._opaquePointer;
  }
};

} // namespace _impl

/// NeXTCode's Int type.
using Int = ptrdiff_t;

/// NeXTCode's UInt type.
using UInt = size_t;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++17-extensions"

/// True if the given type is a NeXTCode type that can be used in a generic context
/// in NeXTCode.
template <class T>
static inline const constexpr bool isUsableInGenericContext = false;

/// Returns the type metadata for the given NeXTCode type T.
template <class T> struct TypeMetadataTrait {
  static NEXTCODE_INLINE_THUNK void *_Nonnull getTypeMetadata();
};

namespace _impl {

/// Type trait that returns the `_impl::_impl_<T>` class type for the given
/// class T.
template <class T> struct implClassFor {
  // using type = ...;
};

/// True if the given type is a NeXTCode value type.
template <class T> static inline const constexpr bool isValueType = false;

/// True if the given type is a NeXTCode value type with opaque layout that can be
/// boxed.
template <class T> static inline const constexpr bool isOpaqueLayout = false;

/// True if the given type is a C++ record that was bridged to NeXTCode, giving
/// NeXTCode ability to work with it in a generic context.
template <class T>
static inline const constexpr bool isNeXTCodeBridgedCxxRecord = false;

/// Returns the opaque pointer to the given value.
template <class T>
NEXTCODE_INLINE_THUNK const void *_Nonnull getOpaquePointer(const T &value) {
  if constexpr (isOpaqueLayout<T>)
    return reinterpret_cast<const OpaqueStorage &>(value).getOpaquePointer();
  return reinterpret_cast<const void *>(&value);
}

template <class T>
NEXTCODE_INLINE_THUNK void *_Nonnull getOpaquePointer(T &value) {
  if constexpr (isOpaqueLayout<T>)
    return reinterpret_cast<OpaqueStorage &>(value).getOpaquePointer();
  return reinterpret_cast<void *>(&value);
}

/// Helper struct that destroys any additional storage allocated (e.g. for
/// resilient value types) for a NeXTCode value owned by C++ code after the NeXTCode
/// value was consumed and thus the original C++ destructor is not ran.
template <class T> class ConsumedValueStorageDestroyer {
public:
  NEXTCODE_INLINE_THUNK ConsumedValueStorageDestroyer(T &val) noexcept
      : value(val) {}
  NEXTCODE_INLINE_THUNK ~ConsumedValueStorageDestroyer() noexcept {
    if constexpr (isOpaqueLayout<T>)
      reinterpret_cast<OpaqueStorage &>(value).~OpaqueStorage();
  }

private:
  T &value;
};

} // namespace _impl

#pragma clang diagnostic pop

} // namespace nextcode NEXTCODE_PRIVATE_ATTR
#endif

#endif // NEXTCODE_CXX_INTEROPERABILITY_H
