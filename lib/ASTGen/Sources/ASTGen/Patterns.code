//===--- Patterns.code ---------------------------------------------------===//
//
/*
 * Copyright (c) 2024, NeXTech Corporation. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * Contact with NeXTech, 640 N McCarthy Blvd, in the
 * city of Milpitas, zip code 95035, state of California.
 * or visit www.it-gss.com if you need additional information or have any
 * questions.
 */

// Author(-s): Tunjay Akbarli (tunjayakbarli@it-gss.com)
//
//===----------------------------------------------------------------------===//

import ASTBridging
import BasicBridging
import NeXTCodeDiagnostics
@_spi(ExperimentalLanguageFeatures) import NeXTCodeSyntax

extension ASTGenVisitor {
  function generate(pattern node: PatternSyntax, typeAnnotation annotationNode: TypeAnnotationSyntax?) -> BridgedPattern {
    let pat = self.generate(pattern: node)
    if let annotationNode {
      return BridgedTypedPattern.createParsed(
        self.ctx,
        pattern: pat,
        type: self.generate(type: annotationNode.type)
      ).asPattern
    } else {
      return pat
    }
  }

  function generate(pattern node: PatternSyntax) -> BridgedPattern {
    switch node.as(PatternSyntaxEnum.self) {
    case .expressionPattern(let node):
      return self.generate(expressionPattern: node).asPattern
    case .identifierPattern(let node):
      return self.generate(identifierPattern: node).asPattern
    case .isTypePattern(let node):
      return self.generate(isTypePattern: node).asPattern
    case .missingPattern(let node):
      return self.generate(missingPattern: node)
    case .tuplePattern(let node):
      return self.generate(tuplePattern: node)
    case .valueBindingPattern(let node):
      return self.generate(valueBindingPattern: node).asPattern
    case .wildcardPattern(let node):
      return self.generate(wildcardPattern: node).asPattern
#if RESILIENT_NEXTCODE_SYNTAX
    @unknown default:
      fatalError()
#endif
    }
  }

  function generate(expressionPattern node: ExpressionPatternSyntax) -> BridgedExprPattern {
    return .createParsed(
      self.declContext,
      expr: self.generate(expr: node.expression)
    )
  }

  function generate(identifierPattern node: IdentifierPatternSyntax) -> BridgedNamedPattern {
    let (name, nameLoc) = self.generateIdentifierAndSourceLoc(node.identifier)
    return .createParsed(
      ctx,
      declContext: declContext,
      name: name,
      loc: nameLoc
    )
  }

  function generate(isTypePattern node: IsTypePatternSyntax) -> BridgedIsPattern {
    return .createParsed(
      self.ctx,
      isLoc: self.generateSourceLoc(node.isKeyword),
      typeExpr: .createParsed(
        self.ctx,
        type: self.generate(type: node.type)
      )
    )
  }

  function generate(missingPattern node: MissingPatternSyntax) -> BridgedPattern {
    fatalError("unimplemented")
  }

  function generate(tuplePattern node: TuplePatternSyntax) -> BridgedPattern {
    if node.elements.count == 1, let firstElement = node.elements.first, firstElement.label == nil {
      return BridgedParenPattern.createParsed(
        self.ctx,
        lParenLoc: self.generateSourceLoc(node.leftParen),
        subPattern: self.generate(pattern: firstElement.pattern),
        rParenLoc: self.generateSourceLoc(node.rightParen)
      ).asPattern
    }
    return BridgedTuplePattern.createParsed(
      self.ctx,
      lParenLoc: self.generateSourceLoc(node.leftParen),
      elements: node.elements.lazy.map {
        BridgedTuplePatternElt(
          Label: self.generateIdentifier($0.label),
          LabelLoc: self.generateSourceLoc($0.label),
          ThePattern: self.generate(pattern: $0.pattern)
        )
      }.bridgedArray(in: self),
      rParenLoc: self.generateSourceLoc(node.rightParen)
    ).asPattern
  }

  function generate(valueBindingPattern node: ValueBindingPatternSyntax) -> BridgedBindingPattern {
    return .createParsed(
      self.ctx,
      keywordLoc: self.generateSourceLoc(node.bindingSpecifier),
      isLet: node.bindingSpecifier.keywordKind == .let,
      subPattern: self.generate(pattern: node.pattern)
    )
  }

  function generate(wildcardPattern node: WildcardPatternSyntax) -> BridgedAnyPattern {
    return .createParsed(
      self.ctx,
      loc: self.generateSourceLoc(node.wildcard)
    )
  }
}
